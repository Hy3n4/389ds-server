---
- name: Check that security.tls_key[_file] is defined
  assert:
    that:
      - "security.tls_key is defined or security.tls_key_file is defined"
    msg: "security.tls_key or security.tls_key_file must be defined"

- name: Check that security.tls_cert[_file] is defined
  assert:
    that:
      - "security.tls_cert is defined or security.tls_cert_file is defined"
    msg: "security.tls_cert or security.tls_cert_file must be defined"

- block:
  - name: Copy cert (from variable)
    copy:
      content: "{{ security.tls_cert }}"
      dest: "/tmp/disrsrv-{{ serverid }}_ansible_managed.crt"
      mode: '400'
      setype: cert_t
    when: security.tls_cert is defined

  # TODO: if the file is already on the remote machine, copying it to /tmp is a pointless waste of time...
  - name: Copy cert (from file)
    copy:
      src: "{{ security.tls_cert_file }}"
      dest: "/tmp/disrsrv-{{ serverid }}_ansible_managed.crt"
      remote_src: "{{ security.tls_files_remote }}"
      mode: '400'
      setype: cert_t
    when: security.tls_cert_file is defined

  # TODO: this should be a nice way to avoid re-adding certificates to the NSS db, but too complicated to implement
  #- name: Check {{ serverid }} certificate serial number
  #  shell: certutil -L -d /etc/dirsrv/slapd-{{ serverid }} -n disrsrv-ldap_ansible_managed
  #  register: certutil_tls
  #  failed_when: not( (certutil_tls.rc == 0) or ('stderr' in certutil_tls and 'PR_FILE_NOT_FOUND_ERROR' in certutil_tls.stderr) )

  - name: Copy private key (from variable)
    copy:
      content: "{{ security.tls_key }}"
      dest: "/tmp/disrsrv-{{ serverid }}_ansible_managed.key"
      mode: '400'
      setype: cert_t
    when: security.tls_key is defined

  - name: Copy private key (from file)
    copy:
      src: "{{ security.tls_key_file }}"
      dest: "/tmp/disrsrv-{{ serverid }}_ansible_managed.key"
      remote_src: "{{ security.tls_files_remote }}"
      mode: '400'
      setype: cert_t
    when: security.tls_key_file is defined

  - name: Install pyOpenSSL for openssl_pkcs12 module
    package:
      name: pyOpenSSL
      state: present

  - name: Create pkcs12
    openssl_pkcs12:
      action: export
      path: "/tmp/disrsrv-{{ serverid }}_ansible_managed.p12"
      # Mandatory parameter, but apparently a bug
      # https://github.com/ansible/ansible/issues/46047
      friendly_name: "disrsrv-{{ serverid }}_ansible_managed"
      privatekey_path: "/tmp/disrsrv-{{ serverid }}_ansible_managed.key"
      certificate_path: "/tmp/disrsrv-{{ serverid }}_ansible_managed.crt"
      setype: cert_t
      state: present

  - name: Add pkcs12 to {{ serverid }} NSS db
    shell: "/bin/pk12util -i /tmp/disrsrv-{{ serverid }}_ansible_managed.p12 -d /etc/dirsrv/slapd-{{ serverid }} -K '' -W ''"

  # TODO: Why? The manual says to add CA to the instance NSS db,
  # why are we adding it to system-wide trusted CAs?
  # Is this even needed for a public and already trusted CA?
  #
  #- name: copy public cert chain to ca-trust
  #  copy:
  #    content: "{{ security.tls_cert }}"
  #    dest: "/etc/pki/ca-trust/source/anchors/{{ security.tls_cn }}.crt"

  #- name: Add public cert to ca trust
  #  shell: "/bin/update-ca-trust"

  # TODO: -t
  # TODO: add -a if the p12 thing is ASCII encoded (openssl_pkcs12 outputs it in binary format so it's not needed)
  #- name: Install certificate into {{ serverid }} NSS db
  #  command: >
  #    certutil -A
  #    -d '/etc/dirsrv/slapd-{{ serverid }}'
  #    -n 'ansible_managed_{{ serverid }}'
  #    -t 'C,,'
  #    -a
  #    -i '/tmp/disrsrv-{{ serverid }}_ca_ansible_managed.crt'
  #  changed_when: false

  always:
  - name: Remove temporary files
    file:
      state: absent
      path: "{{ item }}"
    loop:
    - "/tmp/disrsrv-{{ serverid }}_ansible_managed.crt"
    - "/tmp/disrsrv-{{ serverid }}_ansible_managed.key"
    - "/tmp/disrsrv-{{ serverid }}_ansible_managed.p12"
